import { Appear } from 'mdx-deck'
import { dark } from 'mdx-deck/themes'
import { CodeSurfer } from "mdx-deck-code-surfer"

# 深入探讨PWA之Service Worker

### 舒晨 shuchery@gmail.com

---


## 几点思考

<ul style={{textAlign: 'left'}}>
  <Appear>
    <li>Service Worker 是什么</li>
    <li>哪些场景可以用到？</li>
    <li>它有哪些能力？</li>
    <li>它跟现有的缓存方案有什么区别？</li>
    <li>它会带来什么问题？</li>
  </Appear>
</ul>

---

## PWA有哪些特点?


---

Web App Manifest
<ul style={{textAlign: 'left'}}>
  <Appear>
    <li>添加到主屏幕</li>
    <li>点击屏幕图标启动，可以自定义启动画面。</li>
    <li>隐藏地址栏。</li>
  </Appear>
</ul>


---

<CodeSurfer
  title="manifest.json"
  code={require("!raw-loader!./snippets/manifest.js")}
  steps={[
    { notes: "根据配置项安装到桌面️" },
    { range: [1, 3], notes: "⬇️" },
    { range: [5, 13], notes: "⬇️" },
    { range: [15, 32], notes: "⬇️" },
    { lines: [30, 35], notes: "⬇️" }
  ]}
/>

---

<CodeSurfer
  title="引入manifest.json"
  code={require("!raw-loader!./snippets/index-html.js")}
  steps={[
    { notes: "index.html" },
    { lines: [4], notes: "index.html️" }
  ]}
/>

<!--模拟器演示淘宝网站安装-->
---

实现资源缓存功能，通过Service Worker实现，资源访问更快

---

实现消息推送 Push Notification，提高网站转化率

---
<span style={{color: 'red'}}>Service Worker</span> 是什么？
---

Service Worker 是基于 Web Worker 的事件驱动。
Web Worker 是脱离于主线程之外的，将耗时的操作或复杂的计算给他干。完成后
通过 postMessage 方法告诉主线程，主线程通过 onMessage 方法得到反馈。
唯一的目的就是解放主线程。

Web Worker 简单例子
http://www.ruanyifeng.com/blog/2018/07/web-worker.html

---

Service Worker 特点
1.线程独立，不影响当前网页渲染。
2.离线缓存静态资源。
3.代理和拦截请求并自定义响应
4.可以通过 postMessage 向主线程发送消息
5.必须在 HTTPS / localhost 环境下工作
6.基于异步 Promise 实现
7.Service Worker 安装后完成后会一直存在，除非手动卸载。
8.无法操作DOM

---

Service Worker 生命周期
1.注册（register）
2.安装（install）
3.激活（activate）

---

注册：
navigator.serviceWorker.register('./sw.js')

———

安装：
缓存一些静态资源文件
cache.addAll(cacheFiles)

---

激活：
清理缓存，更新 Service Worker

self.skipWaiting() 强制更新，替换旧文件

---

使用：
在service worker 第一次创建成功，并没有激活，
只有当刷新页面，再次访问，才能控制页面

self.addEventListener('fetch',function(e){})

---

卸载：


